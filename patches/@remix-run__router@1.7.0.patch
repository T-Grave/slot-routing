diff --git a/dist/router.js b/dist/router.js
index 476e375a5387243e5e206d0b62ba9c3670a69664..cdb157816ecf88b8df65d9ff184b8ac6b8f11171 100644
--- a/dist/router.js
+++ b/dist/router.js
@@ -510,19 +510,45 @@ function matchRoutes(routes, locationArg, basename) {
   if (pathname == null) {
     return null;
   }
+
+  const search = new URLSearchParams(location.search);
+  const slots = [...search.entries()].reduce((acc, entry) => {
+    if (entry[0].startsWith("slot-")) {
+      acc.push(entry);
+    }
+    return acc;
+  }, []);
+  
   let branches = flattenRoutes(routes);
   rankRouteBranches(branches);
-  let matches = null;
-  for (let i = 0; matches == null && i < branches.length; ++i) {
-    matches = matchRouteBranch(branches[i],
-    // Incoming pathnames are generally encoded from either window.location
-    // or from router.navigate, but we want to match against the unencoded
-    // paths in the route definitions.  Memory router locations won't be
-    // encoded here but there also shouldn't be anything to decode so this
-    // should be a safe operation.  This avoids needing matchRoutes to be
-    // history-aware.
-    safelyDecodeURI(pathname));
+
+  function findMatchesForPathname(pathname) {
+    let matches = null;
+    for (let i = 0; matches == null && i < branches.length; ++i) {
+      matches = matchRouteBranch(branches[i],
+      // Incoming pathnames are generally encoded from either window.location
+      // or from router.navigate, but we want to match against the unencoded
+      // paths in the route definitions.  Memory router locations won't be
+      // encoded here but there also shouldn't be anything to decode so this
+      // should be a safe operation.  This avoids needing matchRoutes to be
+      // history-aware.
+      safelyDecodeURI(pathname));
+    }
+    return matches;
   }
+
+  let matches = findMatchesForPathname(pathname);
+
+  // For each slot, we match another branch of routes.
+  // This will make it so a single route will be in the matches multiple times
+  // We will need to add a "slot" prop to differentiate between them in the future.
+  slots.forEach(([key, path]) => {
+    if (path) {
+      const slotMatches = findMatchesForPathname(path);
+      matches.push(...slotMatches);
+    }
+  });
+  
   return matches;
 }
 function flattenRoutes(routes, branches, parentsMeta, parentPath) {